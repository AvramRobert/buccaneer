=== Problems ===
 > 1. Assignments apparently lose their docs.
2. To have commands with no input, I have to provide `Unit` as a value,
   this however is displayed in the options list when help is output.

 > 3. Making unit is the default will lead to ambiguity when commands
   have only options.

=== Ideas ===
1.
Because commands are binary trees, can't I use a huffman encoding to serialise these trees as binary numbers and use this form as keys?

2.
I may perhaps not really need `Tree`. Everything implemented so far is actually pretty linear.


=====================
TODO:
 > 0. HelpConfig should contain the name of the program and use it when no title is found. Also add it to usage.
 > 1. Add the `--help` and `--sgst` options to the MAN page
 > 2. Revise usages. It outputs too much.
3. Add show to Read[A].
4. Add publishing configuration to this project and publish to Maven/Bintray
5. Create a new project for the sbt plugin and import add buccaneer
6. Combine buccaneer API with the sbt.Command API

=====================
Future features:

 > 1. User-defined type-constraints // should be easy
2. User-defined meta-parametrisations // should be somewhat easy
3. Indexing errors by their positions while validating // should also be somewhat easy
4. Variable arguments of one particular type (or for example variable arguments of key-value pairs)
5. Dependent argument. Check the value of one argument against the value of the previous argument
6. Interactive mode, backed by the Cli itself

Formatter:
    Idea: Define a formatter in terms of what can be done at each line.
     One such formatter would have three specific cases, that would need handling:
       1. Apply some formatting at every line of the input.
       2. Apply some formatting at some subset of lines of the input.
       3. Apply some formatting at one specific line of the input.
     Additionally, there could also exist some transitive relation between formats. For example one line might be formatted in
     relation to the previous one. (this is for example the case in hyphenation)
     This would therefore imply some context dependency and might lead to the formation of a Monad.

     Possible monad definitions:
     a) A Monad may be formed by relating one homologous formatting to another. `bind` might describe taking the line, formatting it and
     then using the formatted line to create another formatter that formats it some other way.
     b) A Monad may be formed by relating lines together. For example, given some sub-sequence `F[A]` representing
     a previous line, i can `flatMap` it to create another formatter that formats the `NEXT` line in relation
     to that one.