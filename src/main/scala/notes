1.
TODO: Implement some type of dynamic matching of input -> command & args interpolation.
A command can have multiple variations of arguments, it should be possible that, given an input,
the most appropriate one be selected from defined n. Otherwise an error is reported

2.
TODO: The fairly localized mapping of the new error message makes it, sort of, impossible to externally define error messages, because they simply get overridden
Similar to "unnamed" and "named", add a function for the association command <-> args, without directly calling `:>>`
This could then be treated as a simple combinator that also accepts an error message

Example:
  command("add")
  .dashedArgument("A").param[Int].param[Double] withErr ("Nonono")
  .doubleDashedArgument("B") withErr ("Hello")
  .dashedArgument("A").orElse(_.doubleDashed("A")) withErr ("Nay I say")

3.
IDEA: Differentiation between argument types is sort of redundant and becomes problematic when trying to compose them (hint hint: named param)
Simplify this to some `Argument` ADT and simply let the user define what prefixes he might or might not want to have
 case class Argument(v: String) extends Symbol

   command("add")
    .argument("-A").orElse("--A").param[Int]
    .argument("-B").param[Double]


4.
TODO: Test Traverse laws for Interpolation